# C0文法编译器 

#### 2018300102_李沛琦



## 概要介绍

**本项目用于将一段符合本编译器的C0文法程序编译成栈式指令目标代码，并进一步将栈式目标代码编译成MIPS汇编代码。**



## 特性

**生成的栈式指令目标代码可以在源文件内自定义的栈式结构虚拟机上解释运行，生成的MIPS汇编代码可以在Mars上模拟仿真。C0compiler目录下为工程源代码和测试文件。**



## 环境配置

**开发环境为Windows10 64位操作系统，使用的语言为C++，使用的IDE为Code::Blocks 17.12，自定义栈式结构虚拟机编写语言为C++，生成的MIPS汇编代码的仿真环境为Mars 4.5。**



## 代码规模

**总代码行数(约为4570) = 代码行数(约为3820) + 注释行数(约为750)**

![C0compiler_CodeStatistics.png](https://i.loli.net/2021/07/13/z4trY3LTu9KUegJ.png)



## 项目分模块统计

|                             文件                             |         模块         | 代码行数 |                             功能                             |
| :----------------------------------------------------------: | :------------------: | :------: | :----------------------------------------------------------: |
|                  global.cpp<br />+ global.h                  |     全局变量定义     |   221    |               全局变量和枚举类型与结构体的定义               |
|                    init.cpp<br />+ init.h                    |        初始化        |   169    |                   部分变量和符号集的初始化                   |
|         lexicalAnalysis.cpp<br />+ lexicalAnalysis.h         |       词法分析       |   289    |               将C0程序中的内容解析为一个个单词               |
|     grammaticalAnalysis.cpp<br />+ grammaticalAnalysis.h     |     语法语义分析     |   938    | 根据文法检测C0程序的正确性，<br />并生成目标栈式结构指令代码 |
|    objectCodeProcessing.cpp<br />+ objectCodeProcessing.h    |   栈式指令代码处理   |   119    | 基于目标栈式结构指令指令代码，<br />实现生成虚拟机代码与输出代码 |
|        objectCodeBetter.cpp<br />+ objectCodeBetter.h        |   栈式指令代码优化   |   460    |                对目标栈式结构指令代码进行优化                |
|                  ToMIPS.cpp<br />+ ToMIPS.h                  |   MIPS汇编代码生成   |   919    |    基于目标栈式结构指令代码，<br />生成对应的MIPS汇编代码    |
|           ToMIPS_Better.cpp<br />+ ToMIPS_Better.h           |   MIPS汇编代码优化   |   903    | 基于优化后的目标栈式结构指令代码，<br />生成对应优化后的MIPS汇编代码 |
|                           main.cpp                           |        主函数        |   139    |               将各个模块链接起来并设计用户接口               |
|                    error.cpp<br />error.h                    |       错误处理       |   109    |                      对错误进行统一处理                      |
| virtualMachineOf<br />StackStructure.cpp<br />+ virtualMachineOf<br />StackStructure.h | 自定义栈式结构虚拟机 |   302    |            用于解释执行生成的目标栈式结构指令代码            |
| test1.txt + test2.txt <br />+ test3.txt + test4.txt<br />+ test5.txt + testFibo.txt<br />+ testTotal.txt <br />+ testError.txt<br />+ testBetter.txt |       测试用例       |   238    |    用于测试项目的正确性，<br />具体内容见下方测试用例部分    |

![CodeModuleStatistics.jpg](https://i.loli.net/2021/07/14/GHePFvw41XljIgz.jpg)



## 语言文法说明

**本项目文法定义采用的是部分C0文法(非扩展C0)，其定义见附表1；生成的目标代码为栈式结构指令代码，其指令定义见附表2；最终由目标栈式结构指令代码生成MIPS汇编代码，其指令集见附表3。**



## 优化内容说明

**目前采用了效果明显且易于实现的窥孔优化，实现方式有：死代码删除、删除冗余的取和存、常量合并、代数化简几种优化方式优化方式。**

**由于采用的目标代码栈式结构指令代码在跨基本块操作过程的指令有明显特征，因此我通过控制窥孔窗口的大小来保证不会出现因为跨基本块进行优化而产生的错误。**

**另外，还可基于我实现的窥孔优化方式的框架，基于对应虚拟机偏好进一步采用常量传播、控制流优化、强度削弱、使用目标机惯用指令等优化方式，不过由于我才用的虚拟机没有设置明显运算或操作偏好，因此这后几种优化方式未在代码中体现，仅在注释中提供思路。**

**基于目标栈式结构指令代码的优化过程需要计算优化后需要修正的偏移量，从而保证跳转语句的正确性，具体的优化内容如下，更多详细内容见源代码。**

**死代码删除技术：**
		**窥孔大小为2**
		**LIT 0 0  JPC 0 a   ->   窥孔头直接移至第a行**
		**跳转修正偏移量增量为A2-SN2+1**

**删除冗余的取和存技术：**
		**窥孔大小为2**
		**LOD 0 a	STO 0 b	LOD 0 b	STO 0 a   ->   LOD 0 a	STO 0 b**
		**跳转修正偏移量增量为2**

**常量合并技术：**
		**窥孔大小为3**
		**LIT 0 a	LIT 0 b	(ADD|SUB|MUL|DIV) 0 0  ->  LIT 0 c	[c=a(ADD|SUB|MUL|DIV)b]**
		**跳转修正偏移量增量为2**

**代数化简技术:**
		**窥孔大小为4**
		**<1> LOD 0 a	LIT 0 0  	(ADD|SUB) 0 0	STO 0 a  ->   NULL**
		**<2> LIT 0 0	  LOD 0 a	ADD 0 0      	      STO 0 a  ->   NULL**
		**<3> LOD 0 a	LIT 0 1      (MUL|DIV) 0 0 	STO 0 a  ->   NULL**
		**<4> LIT 0 1	  LOD 0 a	MUL 0 0      		  STO 0 a  ->   NULL**
		**跳转修正偏移量增量为4**





## 栈式结构指令代码=>MIPS汇编代码的设计说明

**由于我自定义的栈式结构指令代码操作与内容已经十分接近MIPS汇编代码，因此大部分操作都可以对栈式结构指令代码进行线性扫描然后翻译并生成对应的MIPS汇编代码。**

**但是还是有一些操作不能直接通过单条栈式结构指令代码生成对应的MIPS汇编，于是我设置了一个窥孔来进行对栈式结构指令代码的线性扫描，根据上下文生成MIPS汇编代码，即可解决除while语句外的其他转化问题，详细内容见源码。**

**对while语句，分析得知，其栈式结构指令的特征为:while语句开始、条件判断、条件为假则跳转至while语句结束的有条件跳转、while函数体、无条件跳转至while语句开始。为此，在线性扫描栈式结构指令时，对每个有条件跳转指令的条件判断前都预写WhileStart的标记，在之后扫描到跳转至while语句开始的无条件跳转语句后，令其无条件跳转至对应的WhileStart标记。最后再对生成的MIPS汇编代码进行一边扫描，删除冗余的预写WhileStart标记，对正确匹配的while语句分配正确的跳转标记序号。**



## 使用方法

**打开工程文件C0compiler.cbp，运行其中的main.cpp主函数，或者直接运行源文件中的C0compiler.exe可执行文件。**

**运行后首先要初始化几个Switch，输入Y或y为开关启用，反之Switch不启用**。

**While Enable Switch用于控制编译器是否循环运行，若需要编译多个文件则启用，反之不启用，编译一个文件后则退出。**

**Print Name Table Enable Switch用于控制名字表的生成与打印，只有启用该Switch才能正常编译，如果不想编译目前文件可以将其置为不启用。**

**Print Object Code List Enable Switch用于控制目标栈式指令代码的打印，如果希望阅读生成的栈式指令代码，则将该Switch启用，反正不启用，则直接进入虚拟机解释执行部分。**

**Object Code Better Enable Switch用于控制目标栈式指令代码和MIPS汇编代码的优化，若待编译C0文法程序中可优化的内容较少，优化效果并不明显，可以不启用该Switch，反之若待编译C0文法程序中可优化的内容较多，优化效果比较明显，启用该Switch，可以得到优化后的目标栈式指令代码和MIPS汇编代码。**

**生成目标栈式代码后本程序回调用自定义栈式结构虚拟机对生成的目标栈式代码进行解释执行(若有输入输出则会在此时进行输入输出)，生成的MIPS汇编代码可以后续在Mars上进行模拟仿真。**

**每一个编译循环结束后会生成(更新)以下五个tmp文件：f_nameList.tmp储存生成的名字表(符号表)，f_objectCode.tmp储存生成的目标栈式指令代码，f_objectCodeBetter.tmp储存优化后的目标栈式指令代码，f_objectCodeToMIPS.asm.tmp储存生成的MIPS汇编代码，f_objectCodeToMIPS_Better.asm.tmp储存优化后的MIPS汇编代码。**



## 测试用例

**编写了几个自定义测试用例：test1.txt、test2.txt、test3.txt、test4.txt、test5.txt、testFibo.txt、testTotal.txt、testError.txt、testBetter.txt，以下大致说明一下每个测试用例的内容与用途和一组测试结果正确的输入输出。具体测试文件见源码。**

***test1.txt：***

**输入a,b,c，输出(b+c)和a(b+c)。**

![C0compiler_test1.png](https://i.loli.net/2021/07/12/zGJEOyU6LF17IKS.png)

***test2.txt：***

**采用有重复的变量名，尝试直接和调用函数进行Printf()输出11、22、33、44。**

![C0compiler_test2.png](https://i.loli.net/2021/07/12/2O6VhQb7BwTpi5s.png)

***test3.txt：***

**定义a=1,b=2,c=3,d=4，输入aa，计算aa=aa+1,aa=aa-1,aa=aa\*2,aa=aa/2,aa=aa+a,aa=aa-b,aa=aa\*c,aa=aa/d，并输出逐步aa的值，用于分别测试变量与常量和变量的四则运算。**

![C0compiler_test3.png](https://i.loli.net/2021/07/12/5cXAbZFYWzJlfvt.png)

***test4.txt：***

**全部采用相同的变量名a，调用三个不同的函数printf(a)输出1、2、3，再在主函数中printf(a)输出4。**

![C0compiler_test4.png](https://i.loli.net/2021/07/12/IgGhEJP8jKCoNuU.png)

***test5.txt：***

**输入n(0<n<=12)，逐行输出1-n的阶乘。**

![C0compiler_test5.png](https://i.loli.net/2021/07/12/lHhSWExavR4gLO7.png)

***testFibo.txt：***

**输入n(0<n<=46),逐行从0-n输出项数n、Fibonacci数列第n项的值、分界符1111111111。**

![C0compiler_testFibo.png](https://i.loli.net/2021/07/12/5buXPszNgLQakjw.png)

***testTotal.txt:***

**采用各种运算式、if/if-else条件语句、while循环语句、函数调用等方式输出0-12。**

![C0compiler_testTotal.png](https://i.loli.net/2021/07/12/xhaZUXAlpRHYkdr.png)

***testError.txt:***

**一段有错误的函数，检查编译时抛出的报错是否正确。**

![C0compiler_testError.png](https://i.loli.net/2021/07/12/69Ome4a2h8gDX5w.png)

***testBetter.txt:***

**一段较为冗余的代码，输入a,b，输出三遍(a+b)。该段测试代码优化前后对比效果明显，优化前栈式指令代码为**

**73行、MIPS汇编代码(含初始化)为144行，优化后栈式指令代码为26行、MIPS汇编代码(含初始化)为64行。**

![C0compiler_testBetter.png](https://i.loli.net/2021/07/12/6QIKDyYM29VS5WB.png)



## 更多文档

**本工程的其他详细信息见与源代码一并提交的实验报告文档。**



## 附表1 C0文法定义

| ＜加法运算符＞ ::= +｜-                                      |
| :----------------------------------------------------------- |
| **＜乘法运算符＞ ::= *｜/**                                  |
| **＜字母＞             ::= ＿｜a｜．．．｜z｜A｜．．．｜Z**  |
| **＜数字＞             ::= ０｜＜非零数字＞**                |
| **＜非零数字＞     ::= １｜．．．｜９**                      |
| **＜字符＞             ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'** |
| **＜字符串＞         ::=  "｛十进制编码为32,33,35-126的ASCII字符｝"** |
| **＜程序＞             ::= ［＜变量说明＞］{＜无返回值函数定义＞}＜主函数＞** |
| **＜无符号整数＞ ::= ＜非零数字＞｛＜数字＞｝**              |
| **＜整数＞             ::= ［＋｜－］＜无符号整数＞｜０**    |
| **＜标识符＞         ::=  ＜字母＞｛＜字母＞｜＜数字＞｝**   |
| **＜声明头部＞     ::=  int＜标识符＞**                      |
| **＜变量说明＞     ::= ＜变量定义＞;{＜变量定义＞;}**        |
| **＜变量定义＞     ::= ＜类型标识符＞＜标识符＞{,＜标识符＞ }** |
| **＜类型标识符＞ ::=  int**                                  |
| **＜复合语句＞     ::= ［＜变量说明＞］＜语句列＞**          |
| **＜参数表＞         ::= ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}\|＜空＞** |
| **＜主函数＞         ::= void main‘(’‘)’ ‘{’＜复合语句＞‘}’** |
| **＜表达式＞         ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}** |
| **＜项＞                 ::= ＜因子＞{＜乘法运算符＞＜因子＞}** |
| **＜因子＞             ::= ＜标识符＞｜＜整数＞\|＜字符＞｜‘(’＜表达式＞‘)’** |
| **＜语句＞             ::= ＜条件语句＞｜＜循环语句＞｜＜无返回值函数调用语句＞;｜<br/>                                  ＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;｜＜返回语句＞;** |
| **＜赋值语句＞     ::=  ＜标识符＞＝＜表达式＞**             |
| **＜条件语句＞     ::=  if ‘(’＜表达式＞‘)’＜语句＞**        |
| **＜循环语句＞     ::=  while ‘(’＜表达式＞‘)’＜语句＞**     |
| **＜值参数表＞     ::= ＜表达式＞{,＜表达式＞}｜＜空＞**     |
| **＜语句列＞         ::=｛＜语句＞｝**                       |
| **＜读语句＞         ::=  scanf ‘(’＜标识符＞‘)’**           |
| **＜写语句＞         ::=  printf‘(’＜表达式＞‘)’**           |
| **＜返回语句＞     ::=  return[‘(’＜表达式＞‘)’]**           |
| **＜无返回值函数定义＞ ::= void＜标识符＞‘(’＜参数表＞‘)’‘{’＜复合语句＞‘}’** |
| **＜无返回值函数调用语句＞ ::= ＜标识符＞‘(’＜值参数表＞‘)’** |



## 附表2 栈式指令定义

| 指令格式 |                         指 令 功 能                          |
| :------: | :----------------------------------------------------------: |
| LIT 0 A  |          将常数值取到栈顶,A为常数值,stackTop_Ptr+1           |
| LOD L A  |  将层差为L、偏移量为A的存储单元的值取到栈顶,stackTop_Ptr+1   |
| STO L A  |  将栈顶元素的值存入层差为L、偏移量为A的单元,stackTop_Ptr-1   |
| CAL 0 A  |                    调用地址为A的函数过程                     |
| INT 0 A  |      在运行栈中为被调用的函数过程开辟A个单元的存储区域       |
| JMP 0 A  |                      无条件跳转至地址A                       |
| JPC 0 A  | 条件跳转,当栈顶元素为0则跳转至地址A,否则顺序执行,stackTop_Ptr-1 |
| ADD 0 0  | 次栈顶的值与栈顶的值相加,退两个栈元素,结果值进栈,stackTop_Ptr-1 |
| SUB 0 0  | 次栈顶的值与栈顶的值相减,退两个栈元素,结果值进栈,stackTop_Ptr-1 |
| MUL 0 0  | 次栈顶的值与栈顶的值相乘,退两个栈元素,果值进栈,stackTop_Ptr-1 |
| DIV 0 0  | 次栈顶的值除以栈顶的值,退两个栈元素,结果值进栈,stackTop_Ptr-1 |
| RED 0 0  |      从控制台读取一个输入,并将其置于栈顶,stackTop_Ptr+1      |
| WRT 0 0  |         将栈顶元素输出至控制台,并换行,stackTop_Ptr-1         |
| RET 0 0  |              函数调用结束后，返回调用点，并退栈              |



## 附表3 MIPS汇编指令集

| 指令助记符与指令格式           |                     指令功能简述                     |
| :----------------------------- | :--------------------------------------------------: |
| li      $t0     Immde          |               取立即数Immde至寄存器$t0               |
| lw      $t0     Ofs($fp)       |           取内存Ofs($fp)中的值至寄存器$t0            |
| la      $a0     Msg            |                   取Msg的地址至$a0                   |
| sw      $t0     Ofs($fp)       |               存$t0的值至内存Ofs($fp)                |
| subi    $t0     $t0     Immde  |              减立即数,$t0 <- $t0-Immde               |
| add     $t0     $t0     $t1    |               加法运算,$t0 <- $t0+$t1                |
| sub     $t0     $t0     $t1    |               减法运算,$t0 <- $t0-$t1                |
| mul     $t0     $t0     $t1    |               乘法运算,$t0 <- $t0*$t1                |
| div     $t0     $t0     $t1    |               除法运算,$t0 <- $t0/$t1                |
| beq     $t0     $t1     _Lable |          相等跳转,若$t0==$t1,则跳转至_Lable          |
| j               _Lable         |               无条件跳转,跳转至_Lable                |
| jr              $ra            |      无条件寄存器跳转,跳转至寄存器$ra储存的地址      |
| jal             Func           | 无条件直接跳转至子程序Func,并保存返回地址至寄存器$ra |
| move    $s0     $s1            |              寄存器间值传递,$s0 <- $s1               |
| ori     $s0     $s1     Immde  |     立即数按位或,$s0 <- $s1 \|(zero-extend)Immde     |
| nop                            |                       空转指令                       |
| syscall                        |                       系统调用                       |

